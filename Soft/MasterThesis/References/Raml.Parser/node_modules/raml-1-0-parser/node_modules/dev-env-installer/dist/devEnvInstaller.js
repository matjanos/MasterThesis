"use strict";
var moduleUtils = require("./linkedModuleDetector");
var devUtils = require("./devUtils");
var path = require("path");
var fs = require("fs");
function getModuleGitFolderName(module) {
    var lastSlashPos = module.gitUrl.lastIndexOf("/");
    var gitExtPos = module.gitUrl.lastIndexOf(".git");
    if (gitExtPos == -1)
        gitExtPos = module.gitUrl.length;
    var moduleName = module.gitUrl.substr(lastSlashPos + 1, gitExtPos - lastSlashPos - 1);
    return moduleName;
}
function getExistingModules(folder, modulesToTest) {
    if (!fs.existsSync(folder))
        return {};
    var result = {};
    moduleUtils.subDirectories(folder).forEach(function (subDirectory) {
        var absolutePath = path.join(folder, subDirectory);
        var module = moduleUtils.moduleFromFolder(absolutePath, modulesToTest);
        if (module) {
            module.fsLocation = absolutePath;
            result[module.name] = module;
        }
    });
    return result;
}
function findModulePath(folder, module) {
    if (!fs.existsSync(folder))
        return null;
    var modules = {};
    modules[module.name] = module;
    moduleUtils.subDirectories(folder).forEach(function (subDirectory) {
        var absolutePath = path.join(folder, subDirectory);
        var module = moduleUtils.moduleFromFolder(absolutePath, modules);
        if (module) {
            module.fsLocation = absolutePath;
        }
    });
    return module.fsLocation;
}
function cloneRepositories(rootPath, modules) {
    var existingModules = getExistingModules(rootPath, modules);
    var result = [];
    Object.keys(modules).forEach(function (moduleName) {
        var module = modules[moduleName];
        var modulePath = path.join(rootPath, getModuleGitFolderName(module));
        if (fs.existsSync(modulePath)) {
            console.log("Module " + moduleName + " already exists at " +
                modulePath + ", skip cloning");
            result.push(modulePath);
            return;
        }
        if (existingModules[moduleName]) {
            var realPath = existingModules[moduleName].fsLocation;
            console.log("Module " + moduleName + " already exists at " +
                realPath + ", skip cloning");
            result.push(realPath);
            return;
        }
        var cloneCommand = "git clone " + module.gitUrl + " --branch " + module.gitBranch + " --single-branch";
        if (devUtils.execProcess(cloneCommand, rootPath, true) != 0) {
            throw new Error("Failed to clone repository " + module.gitUrl + " : " + module.gitBranch);
        }
        var clonedModulePath = findModulePath(rootPath, module);
        if (!clonedModulePath) {
            console.log("Cloned module " + module.name + " does not match its name");
        }
        else {
            result.push(clonedModulePath);
        }
    });
    return result;
}
function registerNPMModules(repositoryRoots) {
    repositoryRoots.forEach(function (moduleFolder) {
        if (devUtils.execProcess("npm link", moduleFolder, true) != 0) {
            throw new Error("Could not npm link " + moduleFolder);
        }
    });
}
function npmInstall(repositoryRoots) {
    repositoryRoots.forEach(function (moduleFolder) {
        if (devUtils.execProcess("npm install", moduleFolder, true) != 0) {
            throw new Error("Could not npm install " + moduleFolder);
        }
    });
}
function installTypings(repositoryRoots, modules) {
    repositoryRoots.forEach(function (moduleFolder) {
        var module = moduleUtils.moduleFromFolder(moduleFolder, modules);
        if (module && module.installTypings) {
            if (devUtils.execProcess("typings install", moduleFolder, true) != 0) {
                throw new Error("Could not install typings " + moduleFolder);
            }
        }
    });
}
function deleteFolderRecursive(folder) {
    if (fs.existsSync(folder)) {
        fs.readdirSync(folder).forEach(function (fileName) {
            var childPath = path.join(folder, fileName);
            if (fs.lstatSync(childPath).isDirectory()) {
                deleteFolderRecursive(childPath);
            }
            else {
                fs.unlinkSync(childPath);
            }
        });
        fs.rmdirSync(folder);
    }
}
;
function replaceDependenciesWithLinks(repositoryRoots, modules) {
    repositoryRoots.forEach(function (repositoryRoot) {
        var nodeModulesDir = path.join(repositoryRoot, "node_modules");
        if (!fs.existsSync(nodeModulesDir)) {
            fs.mkdir(nodeModulesDir);
        }
        moduleUtils.subDirectories(nodeModulesDir).forEach(function (subDirectoryName) {
            var subDirectoryAbsolutePath = path.join(nodeModulesDir, subDirectoryName);
            if (fs.realpathSync(subDirectoryAbsolutePath) != subDirectoryAbsolutePath)
                return;
            var module = moduleUtils.moduleFromFolder(subDirectoryAbsolutePath, modules);
            if (!module)
                return;
            deleteFolderRecursive(subDirectoryAbsolutePath);
            if (devUtils.execProcess("npm link " + module.name, nodeModulesDir, true) != 0) {
                throw new Error("Could not npm link " + module.name + " in " + nodeModulesDir);
            }
        });
    });
}
function setupModules(repositoryRoots, modules) {
    registerNPMModules(repositoryRoots);
    npmInstall(repositoryRoots);
    installTypings(repositoryRoots, modules);
    replaceDependenciesWithLinks(repositoryRoots, modules);
}
function setUp(rootFolder, workspaceDescriptorFile) {
    var staticModulesMap = moduleUtils.loadModulesStaticInfo(workspaceDescriptorFile);
    var repositoryRoots = cloneRepositories(rootFolder, staticModulesMap);
    repositoryRoots.forEach(function (repositoryRoot) { return console.log("Reporoot: " + repositoryRoot); });
    setupModules(repositoryRoots, staticModulesMap);
}
exports.setUp = setUp;
//# sourceMappingURL=devEnvInstaller.js.map