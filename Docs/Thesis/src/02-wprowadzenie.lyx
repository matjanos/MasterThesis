#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_removed_modules
dcs
\end_removed_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Wprowadzenie
\end_layout

\begin_layout Section
Architektura oparta o mikrousługi
\end_layout

\begin_layout Subsection
Architektura zorientowana na usługi
\end_layout

\begin_layout Standard
Koncept architektury mikrousług, mimo, że w ostatnich kilkunastu miesiącach
 stał się szeroko omawianym tematem, powszechnie uważanym za innowację,
 to rozszerza tylko podejście, które istnieje od dawna jako SOA (ang.
 
\emph on
Service-Oriented Architecture
\emph default
).
 SOA to architektura łącząca wiele komponentów, których komunikacja odbywa
 się nie w granicach procesu, ale również przez sieć komputerową.
 Ściślej mówiąc, komunikacja powinna niejako ignorować fakt fizycznej lokalizacj
i procesu wywołującego jak i wywoływanego.
 System w ten sam sposób powinien zachować się zarówno uruchomiony na jednej
 maszynie jak i na wielu maszynach mieszczących się na różnych kontynentach.
 
\end_layout

\begin_layout Standard
Taka granulacja umożliwia lepsze wykorzystanie zasobów, poprzez dedykowanie
 ich konkretnym komponentom w zależności od nakładu pracy, który jest wykonywany.
 Stosuje się podejście tworzenia wielu drobnych (
\emph on
ang.
 fine-grained
\emph default
) aplikacji przeznaczonych do jednego zadania.
\begin_inset CommandInset citation
LatexCommand cite
key "TankovicBogunovicGrbacEtAl2015"

\end_inset

 Pozwala to na skalowanie tylko obciążonej części przetwarzania, aby udrożnić
 wąskie gardło systemu.
\end_layout

\begin_layout Subsection
Domain Driven Design jako źródło mikrousług
\end_layout

\begin_layout Standard
Procesem rozwoju oprogramowania rządzi szereg podstawowych zasad, które
 umożliwiają skuteczne pisanie, a przede wszystkich utrzymywanie istniejącego
 kodu.
 Jedną z najważniejszch w ocenie autora reguł jest zasada pojedynczej odpowiedzi
alności, stanowiąca o tym, że każda funkcjonalność powinna być realizowana
 przez jedną wydzieloną część kodu i tylko przez nią.
 Na poziomie programowania zorientowanego obiektowo jest to klasa, na poziomie
 projektu jest to pakiet, a na poziomie architektury może być to komponent.
 Koncepcja projektowania aplikacji w oparciu o tę zasadę została nazwana
 zasadą projektowania sterowanego dziedziną (ang.

\emph on
 Domain Driven Design
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

 i ostatnio bardzo często spotykanym paradygmatem prezentowania rzeczywistego
 świata w kodzie źródłowym.
 
\end_layout

\begin_layout Standard
Według tego podejścia, cały proces wytwarzania oprogramowania, począwszy
 od zbieranie wymagań, przez analizę, projektowanie, implementację, aż po
 testowanie i wdrożenie powinno być oparte o wiedzę na temat wycinka rzeczywisto
ści, który mapowany jest na oprogramowanie w celu ułatwienia lub przyspieszenia
 rozwiązywania problemów z nim związanych.
\end_layout

\begin_layout Subsection
Zasada autonomiczności jako źródło problemów
\end_layout

\begin_layout Standard
Tworzenie mikrousług zgodnie z zaleceniami twórców tego konceptu wymaga
 również zmian w strukturach organizacji, która wytwarza system.
 Zmiana taka powinna polegać na zorganizowaniu całych zespołów wokół każdej
 usługi.
 Oczywiście każdy zespół może realizować prace związane z wieloma usługami,
 ale ważne jest aby jedna usługa była rozwijana i ustrzymywana przez jeden
 zespół.
 Podejście takie wymaga stworzenia kilkuosobowych zespołów, w których znajdują
 się graficy, testerzy, projektanci i programiści.
 Zespół ten sam decyduje, kiedy wdroży nową wersję swojej usługi.
 
\end_layout

\begin_layout Standard
Problem pojawia się w momencie, kiedy niezależny zespół wprowadza zmiany,
 które wymagają zmian również po stronie konsumentów.
 Są to tzw.
 
\emph on
zmiany przełomowe
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 
\emph default
Podczas projektowania interfejsów należy statrać się jak najrzadziej wykonywać
 takie zmiany.
 Wymaga to przede wszytkim bardzo dokładnej analizy dziedziny problemu,
 jaki rozwiązuje dana usługa, aby uwzględnić kierunki, w których może się
 ona rozwijać.
 Unikanie zmian nie zawsze będzie możliwe, ale nie każda z nich jest zmianą
 przełomową.
 Np.
 dodanie pola do zwracanego obiektu nie powinno zmienić zachowania konsumanta.
 W tym miejscu należy też wspomnieć o tym, aby konsumentów implementować
 w sposób 
\begin_inset Quotes pld
\end_inset

odporny
\begin_inset Quotes prd
\end_inset

 na zmiany, które nie są przełomowe.
\end_layout

\begin_layout Standard
Niezależnie rozwijane komponenty mimo niezaprzeczalnych korzyści jakie niosą,
 mają też wady i z pewnością jest to dbanie o kompatybilność z oprogramowaniem
 z nich korzystającym.
\end_layout

\begin_layout Section
Komunikacja między usługami
\end_layout

\begin_layout Subsection
Podział monolitu
\end_layout

\begin_layout Standard
Krytyczną decyzją podczas projektowania architektury opartej o mikrousługi
 jest wybór punktów podziału systemu na związane konteksty (
\emph on
ang.
 bounded context
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004,Fowler2014"

\end_inset

 oraz sposobu współdzielenia tych jednostek.
 
\end_layout

\begin_layout Standard
Według Sama Newmana, rozróżnia się dwie techniki dekompozycji systemu monolitycz
nego.
 Pierwszym są pakiety udostępniane w postaci bibliotek współdzielonych,
 a drugim moduły, które mogą mieć wydzielony stos technologiczny.
 Każde z tych rozwiązań ma zarówno szereg zalet jak i wad, co sprawia, że
 powinny być zastosowane do różnych celów.
\end_layout

\begin_layout Standard
Biblioteki współdzielone mogą zostać wykorzystane w znakomitej większości
 języków i technologii, np.
 C#, Java, lub PHP.
 Dzielą one kod w logiczne jednostki, które mogą być importowane do wielu
 projektów.
 Takie biblioteki mogą być dostarczane zarówno przez zewnętrzne instytucje
 jak i udostępniane wewnątrz firmy.
 Mimo łatwości w używaniu takich bibliotek, należy wziąć pod uwagę zalety
 z których rezygnujemy.
 Najważniejszą z nich jest oczywiście heterogeniczność - biblioteki zazwyczaj
 mogą być uruchomione tylko przez aplikację skompilowaną dla tej samej platformy
 i w tym samym języku.
 Oprócz tego, aktualizacja takiej biblioteki wymaga ponownej kompilacji
 i instalacji wszystkich aplikacji z niej korzystających.
 Skalowanie takich pojedynczych komponentów również nie jest możliwe, bez
 duplikacji całych korzystających z niej aplikacji.
 Najlepszym zastosowaniem dla tego typu komponentów są współdzielone elementy
 systemu, które nie są kluczowe z punktu widzenia domeny, np.
 zbiory funkcji matematycznych lub klasy pomocnicze dla refleksji.
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset


\end_layout

\begin_layout Standard
Drugim wariantem jest wyekstrahowanie modułów.
 Moduł jest fragmentem kodu, który realizować powininen proces określony
 w wymaganiach biznesowych systemu.
 Jest to wydzielona część domeny, która realizuje określone przez nią zadania.
 W szczególnym przypadku powinny posiadać własną warstwę dostępu do danych
 lub warstwę prezentacji
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Ważne jest, aby nie unifikować pojęcia związanego kontekstu z modułem
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

.
 Związany kontekst jest raczej zbiorem modułów, istniejących w tym samym
 celu w sensie domeny.
 Dobrą praktyką jest więc tworzenie kilku warst aplikacji w osobnych modułach
 zawierających się w tej samej przestrzeni nazw, więc wydzielonym kontekście
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

.
\end_layout

\begin_layout Standard
Drugie z tych podejść jest bardziej uwarunkowane różnicami w procesach biznesowy
ch mapowanych na oprogramowanie, więc to taki podział tworzy podwaliny pod
 wydzielenie pełnoprawnych mikrousług.
\end_layout

\begin_layout Subsection
Projektowanie interfejsów REST
\end_layout

\begin_layout Standard
REST (
\emph on
ang.
 Representational State Transfer
\emph default
) to styl architektoniczny przeznaczony dla rozproszonych systemów opartych
 o hipermedia.
 Ma on na celu ułatwienie dostępu do zasobów (
\emph on
ang.
 resources
\emph default
) dla systemów w modelu typu klient-serwer, ze znaczną liczbą aktywnych
 aplikacji klienckich.
 W tym celu, autor konceptu REST określił pięć wymagań, które umożliwiają
 bezpieczny dostęp do zasobów zachowując spójny stan systemu.
 Dodatkowo opisano dodatkowe wymaganie, które jest opcjonalne.
 Opcjonalne wymaganie wydaje się być oksymoronem, ale w dalszej części tej
 sekcji zostanie ono jasno scharakteryzowane.
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset


\end_layout

\begin_layout Standard
Niezmienniki wyspecyfikowane w opisie REST to:
\end_layout

\begin_layout Enumerate
Architektura klient-serwer - zastosowanie tej zasady pozwala rozróżnić pojęcia
 interfejsu użytkownika oraz źródła danych, a także umożliwia skalowanie
 i przenośność poszczególnych komponentów niezależnie, w zależności od potrzeb.
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset


\end_layout

\begin_layout Enumerate
Bezstanowość - niniejsza zasada wprowadza wymóg przekazywania wszystkich
 informacji potrzebnych do realizacji zadania przez serwer w ramach jednego
 żądania; nie jest możliwe przechowywanie stanu po stronie serwera.
 Zasada ta znacząco poprawia niezawodność systemu, gdyż w razie jakichkolwiek
 awarii, nie ma potrzeby odtwarzania stanu przetwarzania aby zrealizować
 poprawnie żądanie.
 Oprócz tego realizacja żądania jest przejrzysta, gdyż nie ma potrzeby analizowa
nia jego zawartości, aby określić naturę wywołania.
 Poprawiona jest w końcu możliwość skalownia systemu, gdyż nie trzeba skalować
 magazynu przechowującego stany aplikacji wszystkich klientów.
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset


\end_layout

\begin_layout Enumerate
Możliwość przechowywanie w pamięci o krótkim czasie dostępu (
\emph on
ang.
 cachability
\emph default
) - jest to zasada wykorzystująca idempotentność operacji, aby zaoszczędzić
 zasoby obliczeniowe serwera, a tym zwiększyć wydajność współpracy aplikacji
 klienckiej i serwerowej.
 Pamiętać należy jednak, że wprowadza to do systemu ewentualną zgodność
 danych odczytanych przez użytkownika i rzeczywistych danych na serwerze.
 Projektując więc interfejsy REST, należy poświęcić dużo uwagi na określenie
 polityki częstotliwości wymuszania odświeżania danych, aby dostosować czas
 uzyskania pełnej zgodności danych do wymagań biznesowych.
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset


\end_layout

\begin_layout Enumerate
Ukrycie warstwowej architektury serwera - jest to zasada polegająca na ukrywaniu
 przed aplikacją kliencką faktu, że aplikacja kliencka jest w rzeczywistości
 zagregowaniem wielu mniejszych aplikacji serwerowych.
 Daje to wiele korzyści, takich jak chociażby umożliwienie skalowania systemów,
 poprzez dodanie komponentu równoważącego obciążenie (
\emph on
ang.
 load balancer
\emph default
 ).
 Jest on wtedy równocześnie serwerem proxy, który w kolejnych warstwach
 może odwoływać się do różnych instancji tej samej aplikacji.
 Możliwe jest również mapowanie zasobów na różne aplikacje serwerowe, bez
 informowania o tym użytkownika lub dokonywanie zmian w aplikacji serwerowej
 bez zmiany implementacji aplikacji klienckich.
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset


\end_layout

\begin_layout Enumerate
Ujednolicony interfejs - ta zasada umożliwia podążanie za konwencją korzystając
 z usług aplikacji serwerowej
\begin_inset CommandInset citation
LatexCommand cite
key "Costa2016"

\end_inset

.
 W tej zasadzie ujawnia się największa zaleta systemów opartych o REST,
 gdyż zapewnia uniwersalność aplikacji serwerowej i proste zasady, które
 spełniać powinna aplikacja kliencka, aby komunikować się z serwerem.
 Według najlepszej wiedzy autora, właśnie to zadecydowało o tak dużej popularnoś
ci interfejsów typu REST.
 Wadą jednolitego interfejsu jest to, że każda aplikacja uzyskuje pełną
 informację o zasobie, bez względu na to jaki ich podzbiór jest przez nią
 wymagany.
 W ramach tego niezmiennika wyróżnia się cztery punkty, opisujące dokładniej
 zasadę ujednoliconego interfejsu
\begin_inset CommandInset citation
LatexCommand cite
key "Athanasopoulos2015,Fielding:2000:ASD:932295"

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
Identyfikacja zasobów - używanie stałych identyfikatorów zasobu (np.
 URI w interfejsach REST opartych o sieć WWW).
\end_layout

\begin_layout Enumerate
Manipulacja zasobami przez ich reprezentację - zasada mówiąca o tym, że
 aplikacja kliencka może manipulować zasobami tylko w zakresie informacji
 uzyskanych przez odczyt.
\end_layout

\begin_layout Enumerate
Samoopisujące się wiadomości - każda wiadomość powinna zawierać wystarczjącą
 informację opisującą jak przetworzyć żądanie.
 Przykładem może być identyfikator MIME w nagłówku `Content-type` w przypadku
 protokołu HTTP
\end_layout

\begin_layout Enumerate
Hipermedium jako silnik stanu aplikacji (
\emph on
ang.
 Hypermedia as the engine of application state
\emph default
) (HATEOAS) - zasada umożliwiająca zrozumienie zasobu i ich zależności dzięki
 rozróżnianiu ich przez stałe identyfikatory oraz reprezentowanie zależności
 przez przekazywanie tych identyfikatorów
\begin_inset CommandInset citation
LatexCommand cite
key "Costa2016"

\end_inset

.
 Niezaprzeczalną wadą tego rozwiązania, jest potrzeba wykonania większej
 ilości zapytań, aby uzyskać pełen obraz bardziej złożonego zasobu.
\end_layout

\end_deeper
\begin_layout Enumerate
Udostępnianie kodu na żądanie* - jest to zasada opcjonalna, która polega
 na umożliwieniu aplikacji klienckiej uzyskiwanie kodu, który można wykonać
 po stronie klienta.
 Przykładem przychodzącym na myśl w pierwszej kolejności jest pobieranie
 kodu JavaScript przez przeglądarki internetowe
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset

.
 Pozorna sprzeczność pojęcia opcjonalnego wymagania, może zostać wyjaśniona
 przez podkreślenie, że system implementujący REST powinien dać sposobność
 wykonania kodu do wykonania, ale wykorzystywanie też możliwości należy
 ograniczyć to szczególnych przypadków przy sprawdzonych warunkach
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset

.
\end_layout

\begin_layout Standard
Specyfika interfejsu typu REST uwydatnia, kwestie które powinny zostać rozważone
 podczas weryfikacji oprogramowania opartego o ten styl architektoniczny.
 Przetestować można wówczas nie tylko funkcjonalne właściwości serwisu,
 ale również zgodność z założeniami stylu w którym jest on realizowany
\begin_inset CommandInset citation
LatexCommand cite
key "Costa2016"

\end_inset

.
\end_layout

\begin_layout Subsection
Połączenia między usługami
\end_layout

\begin_layout Standard
Wizja ogromnego systemu złożonego z wielu komponentów, realizującego skomplikowa
ne zadania nasuwa na myśl skomplikowane połączenia między komórkami systemu.
 Istnieje wiele systemów, w których istnieją dodatkowe komponenty odpowiadające
 tylko i wyłącznie za realizację komunikacji.
 Komponenty takie zaimplementowane mają często skomplikowane reguły przekazywani
a wiadomości w zależności od logiki biznesowej.
 Przykładem są produkty typu ESB (
\emph on
ang.
 Enterprise Service Bus
\emph default
), które zawierają skomplikowane funkcje trasowania wiadomości, kapsułkowania
 lub transformacji danych.
 Komponenty takie, jako że są wspólne dla całego systemu, są trudnos skalowalne,
 więc generują duże ryzyko wystąpienia wąskiego gardła.
 Mechanizm komunikacji powinien być prostą częścią systemu spełniając zasadę
 
\begin_inset Quotes pld
\end_inset

inteligentne punkty końcowe i naiwne kanały komunikacji
\begin_inset Quotes prd
\end_inset

 (
\emph on
ang.
 smart endpoints and dumb pipes
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2014"

\end_inset

.
 Społeczność skupiona na rozwijaniu konceptu mikrousług proponuje proste
 wywołania HTTP w celu wymiany danych między usługami.
 Niższe warstwy sieciowego modelu OSI zrealizują więc komunikację, a zadaniem
 
\begin_inset Quotes pld
\end_inset

inteligentnych punktów końcowych
\begin_inset Quotes prd
\end_inset

 jest analiza żądań i generowanie odpowiedzi.
 
\end_layout

\begin_layout Standard
Wykorzystywanie prostych protokołów komunikacyjnych zrzuca niejako z programistó
w, ciężar projektowania i implementowania mechanizmów komunikacji oraz dostarcza
 całą gamę gotowych i sprawdzonych rozwiązań, które nie obciążają niepotrzebnie
 systemu.
 
\end_layout

\begin_layout Standard
Proste protokoły sieciowe, mimo niezaprzeczalnych zalet w sensie wydajnościowym,
 mogą być niewystarczające dla niektórych zastosowań.
 Protokół HTTP nie jest niezawodny, więc dla krytycznych punktów systemu
 wprowadzić można kolejki komunikatów, które nie realizują logiki biznesowej,
 a tylko zapewniają niezawodność komunikacji asynchronicznej niewielkim
 kosztem wydajności
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/fgcs/ZounmevoA14"

\end_inset

.
\end_layout

\begin_layout Standard
Praktyka pokazuje jednak, że istnieją przypadki, kiedy konieczne jest wyposażeni
e warstwy komunikacyjnej w komponent wspomagający, tzw.
 bramę interfejsów (
\emph on
ang.
 API gateway
\emph default
).
 Brama taka ma za zadanie agregować żądania, możliwie mała ich ilość była
 wymieniana między aplikacją kliencką, a usługami
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Podejście to stosowane jest często w przypadku aplikacji mobilnych, gdzie
 użytkownicy końcowi dysponują limitowaną ilością przesyłanych danych w
 ramach ich pakietu internetowego.
 Ta koncepcja może być zastosowana w dwóch wariantach.
 Pierwszym jest jedna, monolityczna brama interfejsów, która używana jest
 kiedy mamy niewiele (najczęściej jedną) aplikację z niej korzystającą.
 Wariant drugi to odseparowane bramy dla wielu aplikacji końcowych (
\emph on
ang.
 backends for frontends
\emph default
).
 Oba podejścia zaprezentowane są na rysunkach 
\begin_inset CommandInset ref
LatexCommand ref
reference "Ryc21"

\end_inset

 oraz 
\begin_inset CommandInset ref
LatexCommand ref
reference "Ryc22"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Api-Gateway-monolithic.PNG
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Ryc21"

\end_inset

 Monolityczna brama interfejsów.
 Źródło: 
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Api-Gateway-frontend-for-backend.PNG
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Ryc22"

\end_inset

 Wiele bram dla aplikacji końcowych.
 Źródło: 
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Język RAML
\end_layout

\begin_layout Section
Testowanie jednostkowe
\end_layout

\begin_layout Standard
[Samo przepisywanie kodu na mikrousługi jest wystarczająco trudny więc warto
 zaoszczędzić czas na testeowaniu] [S.
 G.
 Saez, V.
 Andrikopoulos, F.
 Wessling, and C.
 C.
 Marquezan, “Cloud Adaptation and Application (Re-)Distribution: Bridging
 the Two Perspectives,” in 2014 IEEE 18th International Enterprise Distributed
 Object Computing Conference Workshops and Demonstrations.
 IEEE, Sep.
 2014, pp.
 163–172.
 [Online].
 Available: http://ieeexplore.ieee.org/articleDetails.jsp?arnumber=6975357]
\end_layout

\end_body
\end_document
