#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_removed_modules
dcs
\end_removed_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Wprowadzenie
\end_layout

\begin_layout Section
Architektura oparta o mikrousługi
\end_layout

\begin_layout Subsection
Architektura zorientowana na usługi
\end_layout

\begin_layout Standard
Koncept architektury mikrousług, mimo, że w ostatnich kilkunastu miesiącach
 stał się szeroko omawianym tematem, powszechnie uważanym za innowację,
 to rozszerza tylko podejście, które istnieje od dawna jako SOA (ang.
 
\emph on
Service-Oriented Architecture
\emph default
).
 SOA to architektura łącząca wiele komponentów, których komunikacja odbywa
 się nie w granicach procesu, ale również przez sieć komputerową.
 Ściślej mówiąc, komunikacja powinna niejako ignorować fakt fizycznej lokalizacj
i procesu wywołującego jak i wywoływanego.
 System w ten sam sposób powinien zachować się zarówno uruchomiony na jednej
 maszynie jak i na wielu maszynach mieszczących się na różnych kontynentach.
 
\end_layout

\begin_layout Standard
Taka granulacja umożliwia lepsze wykorzystanie zasobów, poprzez dedykowanie
 ich konkretnym komponentom w zależności od nakładu pracy, który jest wykonywany.
 Stosuje się podejście tworzenia wielu drobnych (
\emph on
ang.
 fine-grained
\emph default
) aplikacji przeznaczonych do jednego zadania.
\begin_inset CommandInset citation
LatexCommand cite
key "TankovicBogunovicGrbacEtAl2015"

\end_inset

 Pozwala to na skalowanie tylko obciążonej części przetwarzania, aby udrożnić
 wąskie gardło systemu.
\end_layout

\begin_layout Subsection
Domain Driven Design jako źródło mikrousług
\end_layout

\begin_layout Standard
Procesem rozwoju oprogramowania rządzi szereg podstawowych zasad, które
 umożliwiają skuteczne pisanie, a przede wszystkich utrzymywanie istniejącego
 kodu.
 Jedną z najważniejszch w ocenie autora reguł jest zasada pojedynczej odpowiedzi
alności, stanowiąca o tym, że każda funkcjonalność powinna być realizowana
 przez jedną wydzieloną część kodu i tylko przez nią.
 Na poziomie programowania zorientowanego obiektowo jest to klasa, na poziomie
 projektu jest to pakiet, a na poziomie architektury może być to komponent.
 Koncepcja projektowania aplikacji w oparciu o tę zasadę została nazwana
 zasadą projektowania sterowanego dziedziną (ang.

\emph on
 Domain Driven Design
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

 i ostatnio bardzo często spotykanym paradygmatem prezentowania rzeczywistego
 świata w kodzie źródłowym.
 
\end_layout

\begin_layout Standard
Według tego podejścia, cały proces wytwarzania oprogramowania, począwszy
 od zbieranie wymagań, przez analizę, projektowanie, implementację, aż po
 testowanie i wdrożenie powinno być oparte o wiedzę na temat wycinka rzeczywisto
ści, który mapowany jest na oprogramowanie w celu ułatwienia lub przyspieszenia
 rozwiązywania problemów z nim związanych.
\end_layout

\begin_layout Subsection
Zasada autonomiczności jako źródło problemów
\end_layout

\begin_layout Standard
Tworzenie mikrousług zgodnie z zaleceniami twórców tego konceptu wymaga
 również zmian w strukturach organizacji, która wytwarza system.
 Zmiana taka powinna polegać na zorganizowaniu całych zespołów wokół każdej
 usługi.
 Oczywiście każdy zespół może realizować prace związane z wieloma usługami,
 ale ważne jest aby jedna usługa była rozwijana i ustrzymywana przez jeden
 zespół.
 Podejście takie wymaga stworzenia kilkuosobowych zespołów, w których znajdują
 się graficy, testerzy, projektanci i programiści.
 Zespół ten sam decyduje, kiedy wdroży nową wersję swojej usługi.
 
\end_layout

\begin_layout Standard
Problem pojawia się w momencie, kiedy niezależny zespół wprowadza zmiany,
 które wymagają zmian również po stronie konsumentów.
 Są to tzw.
 
\emph on
zmiany przełomowe
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 
\emph default
Podczas projektowania interfejsów należy statrać się jak najrzadziej wykonywać
 takie zmiany.
 Wymaga to przede wszytkim bardzo dokładnej analizy dziedziny problemu,
 jaki rozwiązuje dana usługa, aby uwzględnić kierunki, w których może się
 ona rozwijać.
 Unikanie zmian nie zawsze będzie możliwe, ale nie każda z nich jest zmianą
 przełomową.
 Np.
 dodanie pola do zwracanego obiektu nie powinno zmienić zachowania konsumanta.
 W tym miejscu należy też wspomnieć o tym, aby konsumentów implementować
 w sposób 
\begin_inset Quotes pld
\end_inset

odporny
\begin_inset Quotes prd
\end_inset

 na zmiany, które nie są przełomowe.
\end_layout

\begin_layout Standard
Niezależnie rozwijane komponenty mimo niezaprzeczalnych korzyści jakie niosą,
 mają też wady i z pewnością jest to dbanie o kompatybilność z oprogramowaniem
 z nich korzystającym.
\end_layout

\begin_layout Section
Komunikacja między usługami
\end_layout

\begin_layout Subsection
Podział monolitu
\end_layout

\begin_layout Standard
Krytyczną decyzją podczas projektowania architektury opartej o mikrousługi
 jest wybór punktów podziału systemu na związane konteksty (
\emph on
ang.
 bounded context
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004,Fowler2014"

\end_inset

 oraz sposobu współdzielenia tych jednostek.
 
\end_layout

\begin_layout Standard
Według Sama Newmana, rozróżnia się dwie techniki dekompozycji systemu monolitycz
nego.
 Pierwszym są pakiety udostępniane w postaci bibliotek współdzielonch, a
 drugim moduły, które mogą mieć wydzielony stos technologiczny.
 Każde z tych rozwiązań ma zarówno szereg zalet jak i wad, co sprawia, że
 powinny być zastosowane do różnych celów.
\end_layout

\begin_layout Standard
Biblioteki współdzielone mogą zostać wykorzystane w znakomitej większości
 języków i technologii, np.
 C#, Java, lub PHP.
 Dzielą one kod w logiczne jednostki, które mogą być importowane do wielu
 projektów.
 Takie biblioteki mogą być dostarczane zarówno przez zewnętrzne instytucje
 jak i udostępniane wewnątrz firmy.
 Mimo łatwości w używaniu takich bibliotek, należy wziąć pod uwagę zalety
 z których rezygnujemy.
 Najważniejszą z nich jest oczywiście heterogeniczność - biblioteki zazwyczaj
 mogą być uruchomione tylko przez aplikację skompilowaną dla tej samej platformy
 i w tym samym języku.
 Oprócz tego, aktualizacja takiej biblioteki wymaga rekompilacji i ponownej
 instalacji wszystkich aplikacji z niej korzystających.
 Skalowanie takich pojedynczych komponentów również nie jest możliwe, bez
 duplikacji całych korzystających z niej aplikacji.
 Najlepszym zastosowaniem dla tego typu komponentów są współdzielone elementy
 systemu, które nie są kluczowe z punktu widzenia domeny, np.
 zbiory funkcji matematycznych lub klasy pomocnicze dla refleksji.
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset


\end_layout

\begin_layout Standard
Drugim wariantem jest wyekstrahowanie modułów.
 Moduł jest fragmentem kodu, który realizować powininen proces określony
 w wymaganiach biznesowych systemu.
 Jest to wydzielona część domeny, która realizuje określone przez nią zadania.
 W szczególnym przypadku powinny posiadać własną warstwę dostępu do danych
 lub warstwę prezentacji
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Ważne jest, aby nie unifikować pojęcia związanego kontekstu z modułem
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

.
 Związany kontekst jest raczej zbiorem modułów, istniejących w tym samym
 celu w sensie domeny.
 Dobrą praktyką jest więc tworzenie kilku warst aplikacji w osobnych modułach
 zawierającech się w tej samej przestrzeni nazw, więc wydzielonym kontekście
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

.
\end_layout

\begin_layout Standard
Drugie z tych podejść jest bardziej uwarunkowane różnicami w procesach biznesowy
ch mapowanych na oprogramowanie, więc to taki podział tworzy podwaliny pod
 wydzielenie pełnoprawnych mikrousług.
\end_layout

\begin_layout Subsection
Projektowanie interfejsów REST
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Wersjonowanie interfejsów
\end_layout

\begin_layout Subsection
Połączenia między usługami
\end_layout

\begin_layout Standard
Wizja ogromnego systemu złożonego z wielu komponentów, realizującego skomplikowa
ne zadania nasuwa na myśl skomplikowane połączenia między komórkami systemu.
 Istnieje wiele systemów, w których istnieją dodatkowe komponenty odpowiadające
 tylko i wyłącznie za realizację komunikacji.
 Komponenty takie zaimplementowane mają często skomplikowane reguły przekazywani
a wiadomości w zależności od logiki biznesowej.
 Przykładem są produkty typu ESB (
\emph on
ang.
 Enterprise Service Bus
\emph default
), które zawierają skomplikowane funkcje trasowania wiadomości, kapsułkowania
 lub transformacji danych.
 Kompnenty takie, jako że są wspólne dla całego systemu, są trudnos skalowalne,
 więc generują duże ryzyko wystąpienia wąskiego gardła.
 Mechanizm komunikacji powinien być prostą częścią systemu spełniając zasadę
 
\begin_inset Quotes pld
\end_inset

inteligentne punkty końcowe i naiwne kanały komunikacji
\begin_inset Quotes prd
\end_inset

 (
\emph on
ang.
 smart endpoints and dumb pipes
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2014"

\end_inset

.
 Społeczność skupiona na rozwijaniu konceptu mikrousług proponuje proste
 wywołania HTTP w celu wymiany danych między usługami.
 Niższe warstwy sieciowego modelu OSI zrealizują więc komunikację, a zadaniem
 
\begin_inset Quotes pld
\end_inset

inteligentnych punktów końcowych
\begin_inset Quotes prd
\end_inset

 jest analiza żądań i generowanie odpowiedzi.
 
\end_layout

\begin_layout Standard
Wykorzystywanie prostych protokołów komunikacyjnych zrzuca niejako z programistó
w, ciężar projektowania i implementowania mechanizmów komunikacji oraz dostarcza
 całą gamę gotowych i sprawdzonych rozwiązań, które nie obciążają niepotrzebnie
 systemu.
 
\end_layout

\begin_layout Standard
Proste protokoły sieciowe, mimo niezaprzeczalnych zalet w sensie wydajnościowym,
 mogą być niewystarczające dla niektórych zastosowań.
 Protokół HTTP nie jest niezawodny, więc dla krytycznych punktów systemu
 wprowadzić można kolejki komunikatów, które nie realizują logiki biznesowej,
 a tylko zapewniają niezawodność komunikacji asynchronicznej niewielkim
 kosztem wydajności
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/fgcs/ZounmevoA14"

\end_inset

.
\end_layout

\begin_layout Standard
Praktyka pokazuje jednak, że istnieją przypadki, kiedy konieczne jest wyposażeni
e warstwy komunikacyjnej w komponent wspomagający, tzw.
 bramę interfejsów (
\emph on
ang.
 API gateway
\emph default
).
 Brama taka ma za zadanie agregować żądania, możliwie mała ich ilość była
 wymieniana między aplikacją kliencką, a usługami
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Podejście to stosowane jest często w przypadku aplikacji mobilnych, gdzie
 użytkownicy końcowi dysponują limitowaną ilością przesyłanych danych w
 ramach ich pakietu internetowego.
 Ta koncepcja może być zastosowana w dwóch wariantach.
 Pierwszym jest jedma, monolityczna brama interfejsów, która używana jest
 kiedy mamy niewiele (najczęściej jedną) aplikację z niej korzystającą.
 Wariant drugi to odseparowane bramy dla wielu aplikacji końcowych (
\emph on
ang.
 backends for frontends
\emph default
).
 Oba podejścia zaprezentowane są na rysunkach 
\begin_inset CommandInset ref
LatexCommand ref
reference "Ryc21"

\end_inset

 oraz 
\begin_inset CommandInset ref
LatexCommand ref
reference "Ryc22"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Api-Gateway-monolithic.PNG
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Ryc21"

\end_inset

 Monolityczna brama interfejsów.
 Źródło: 
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Api-Gateway-frontend-for-backend.PNG
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Ryc22"

\end_inset

 Wiele bram dla aplikacji końcowych.
 Źródło: 
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Język RAML
\end_layout

\begin_layout Section
Testowanie jednostkowe
\end_layout

\begin_layout Standard
[Samo przepisywanie kodu na mikrousługi jest wystarczająco trudny więc warto
 zaoszczędzić czas na testeowaniu] [S.
 G.
 Saez, V.
 Andrikopoulos, F.
 Wessling, and C.
 C.
 Marquezan, “Cloud Adaptation and Application (Re-)Distribution: Bridging
 the Two Perspectives,” in 2014 IEEE 18th International Enterprise Distributed
 Object Computing Conference Workshops and Demonstrations.
 IEEE, Sep.
 2014, pp.
 163–172.
 [Online].
 Available: http://ieeexplore.ieee.org/articleDetails.jsp?arnumber=6975357]
\end_layout

\end_body
\end_document
