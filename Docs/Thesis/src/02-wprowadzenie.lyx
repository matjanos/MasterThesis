#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_removed_modules
dcs
\end_removed_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Wprowadzenie
\end_layout

\begin_layout Section
Architektura oparta o mikrousługi
\end_layout

\begin_layout Subsection
Architektura zorientowana na usługi
\begin_inset CommandInset label
LatexCommand label
name "sub:Architektura-zorientowana-na"

\end_inset


\end_layout

\begin_layout Standard
Koncept architektury mikrousług, mimo, że w ostatnich kilkunastu miesiącach
 stał się szeroko omawianym tematem, powszechnie uważanym za innowację,
 to rozszerza tylko podejście, które istnieje od dawna jako SOA (ang.
 
\emph on
Service-Oriented Architecture
\emph default
).
 SOA to architektura łącząca wiele komponentów, których komunikacja odbywa
 się nie w granicach procesu, ale również przez sieć komputerową.
 Ściślej mówiąc, sposób komunikacji nie powinien zależeć od fizycznej lokalizacj
i procesu wywołującego jak i wywoływanego.
 System tak samo powinien zachować się zarówno uruchomiony na jednej maszynie
 jak i na wielu maszynach mieszczących się na różnych kontynentach.
 
\end_layout

\begin_layout Standard
Taka granulacja umożliwia lepsze wykorzystanie zasobów, poprzez dedykowanie
 ich konkretnym komponentom w zależności od nakładu pracy, który jest wykonywany.
 Stosuje się podejście tworzenia wielu drobnych (
\emph on
ang.
 fine-grained
\emph default
) aplikacji przeznaczonych do jednego zadania
\begin_inset CommandInset citation
LatexCommand cite
key "TankovicBogunovicGrbacEtAl2015"

\end_inset

.
 Pozwala to na skalowanie tylko obciążonej części przetwarzania, aby udrożnić
 wąskie gardło systemu.
\end_layout

\begin_layout Subsection
Domain Driven Design
\end_layout

\begin_layout Standard
Procesem rozwoju oprogramowania rządzi szereg podstawowych zasad, które
 umożliwiają skuteczne pisanie, a przede wszystkich utrzymywanie istniejącego
 kodu.
 Jedną z najważniejszch w ocenie autora reguł jest zasada pojedynczej odpowiedzi
alności, stanowiąca o tym, że każda funkcjonalność powinna być realizowana
 przez jedną wydzieloną część kodu i tylko przez nią
\begin_inset CommandInset citation
LatexCommand cite
key "DeMarco1978"

\end_inset

.
 Na poziomie programowania zorientowanego obiektowo jest to klasa, na poziomie
 projektu jest to pakiet, a na poziomie architektury może być to komponent.
 Koncepcja projektowania aplikacji w oparciu o tę zasadę została nazwana
 zasadą projektowania sterowanego dziedziną (ang.

\emph on
 Domain Driven Design
\emph default
, 
\emph on
DDD
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

 i stała się ostatnio bardzo często spotykanym paradygmatem prezentowania
 rzeczywistego świata w kodzie źródłowym.
 
\end_layout

\begin_layout Standard
Według tego podejścia cały proces wytwarzania oprogramowania, począwszy
 od zbierania wymagań, przez analizę, projektowanie, implementację, aż po
 testowanie i wdrożenie powinien być oparty o wiedzę na temat wycinka rzeczywist
ości, który mapowany jest na oprogramowanie w celu ułatwienia lub przyspieszenia
 rozwiązywania problemów z nim związanych.
 Proces mapowania musi się odbywać przy ścisłej współpracy z ekspertami
 w zakresie domeny, gdyż pozwoli projektantom i analitykom w pełni zrozumieć
 odwzorowywane procesy, a także ułatwi przygotowanie systemu na ewentualne
 zmiany i rozszerzenia.
\end_layout

\begin_layout Standard
Bardzo ważnym pojęciem wprowadzonym przez Erica Evansa jest związany kontekst
 (
\emph on
ang.
 bounded context
\emph default
).
 Aplikacja zbudowana zgodnie z DDD zawiera wiele takich kontekstów, wewnątrz
 których znajdują się modele opisujace dany fragment rzeczywistości.
 Ten fragment rzeczywistości to wyodrębniony fragment systemu, który może
 zostać też logicznie wydzielony z punktu widzenia wymagań biznesowych.
 Kontekst, mimo że może posiadać dużą liczbę modeli i ich instancji to prezentuj
e na zewnątrz tylko te najważniejsze, które mają znaczenie z punktu widzenia
 innych związanych kontekstów.
 Przykładem może być system opisujący bibliotekę: kontekst związany zarządzający
 książkami może zawierać informacje na temat uszkodzeń książek, zamówień
 na nowe książki, harmonogramu prac renowacyjnych, itp., ale z punktu widzenia
 związanego kontektsu czytelników, znaczenie ma tylko to czy dana książka
 jest obecnie dostępna i można ją wypożyczyć.
 W tym przykładzie zaprezentowany stan wypożyczenia książki i sama książka
 jest modelem prezentowanym na zewnątrz.
 Należy zwrócić jednak uwagę na to, że ukryte modele, mają wpływ na to czy
 książka będzie oznaczona jako możliwa do wypożyczenia, więc jak najbardziej
 mają znaczenie dla działania danego kontekstu
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015,Evans2004"

\end_inset

.
\end_layout

\begin_layout Standard
Projektowanie sterowane dziedziną stało się skutecznym sposobem podziału
 domeny problemu na mniejsze konteksty i jasnego określenia połączeń między
 nimi.
 Mimo, że ten proces sprawdza się zarówno w systemach monolitycznych jak
 i opartych o mikrousługi, to naturalnie definiuje granice poszczególnych
 usług
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2014"

\end_inset

.
\end_layout

\begin_layout Subsection
Zasada autonomiczności jako źródło problemów
\end_layout

\begin_layout Standard
Zgodnie z zaleceniami twórców konceptu mikrousług, ich tworzenie wymaga
 również zmian w strukturach organizacji, która wytwarza system.
 Zmiana taka powinna polegać na zorganizowaniu całych zespołów wokół każdej
 usługi.
 Oczywiście każdy zespół może realizować prace związane z wieloma usługami,
 ale ważne jest aby jedna usługa była rozwijana i utrzymywana przez jeden
 zespół.
 Podejście takie wymaga stworzenia kilkuosobowych zespołów, w których znajdują
 się graficy, testerzy, projektanci i programiści.
 Zespół ten sam decyduje, kiedy wdroży nową wersję swojej usługi.
 
\end_layout

\begin_layout Standard
Problem pojawia się w momencie, kiedy niezależny zespół wprowadza zmiany,
 które wymagają zmian również po stronie konsumentów.
 Są to tzw.
 zmiany przełomowe
\emph on
 
\emph default
(
\emph on
ang.
 breaking changes
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset


\emph on
.
 
\emph default
Podczas projektowania interfejsów należy starać się jak najrzadziej dokonywać
 takich zmian.
 Wymaga to przede wszytkim bardzo dokładnej analizy dziedziny problemu jaki
 rozwiązuje dana usługa, aby uwzględnić kierunki, w których może się ona
 rozwijać.
 Unikanie zmian nie zawsze będzie możliwe, ale nie każda z nich jest zmianą
 przełomową.
 Na przykład dodanie pola do zwracanego obiektu nie powinno zmienić zachowania
 aplikacji konsumującej dane.
 W tym miejscu należy też wspomnieć o tym, aby konsumentów implementować
 w sposób 
\begin_inset Quotes pld
\end_inset

odporny
\begin_inset Quotes prd
\end_inset

 na zmiany, które nie są przełomowe.
\end_layout

\begin_layout Standard
Niezależnie rozwijane komponenty mimo niezaprzeczalnych korzyści jakie niosą,
 mają też wady i z pewnością jest to dbanie o kompatybilność z oprogramowaniem
 z nich korzystającym.
\end_layout

\begin_layout Section
Komunikacja między usługami
\end_layout

\begin_layout Subsection
Podział monolitu
\end_layout

\begin_layout Standard
Krytyczną decyzją podczas projektowania architektury opartej o mikrousługi
 jest wybór punktów podziału systemu na związane konteksty
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004,Fowler2014"

\end_inset

 oraz sposobu współdzielenia tych jednostek.
 
\end_layout

\begin_layout Standard
Według Sama Newmana, rozróżnia się dwie techniki dekompozycji systemu monolitycz
nego
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Pierwszym z nich są pakiety udostępniane w postaci bibliotek współdzielonych,
 a drugim moduły, które mogą mieć wydzielony stos technologiczny.
 Każde z tych rozwiązań ma zarówno szereg zalet jak i wad, co sprawia, że
 powinny być zastosowane do różnych celów.
\end_layout

\begin_layout Standard
Biblioteki współdzielone mogą zostać wykorzystane w znakomitej większości
 języków i technologii, np.
 C#, Java, lub PHP.
 Dzielą one kod w logiczne jednostki, które mogą być importowane do wielu
 projektów.
 Takie biblioteki mogą być dostarczane zarówno przez zewnętrzne instytucje
 jak i udostępniane wewnątrz firmy.
 Mimo łatwości w używaniu takich bibliotek, należy wziąć pod uwagę zalety
 z których rezygnujemy.
 Najważniejszą z nich jest oczywiście heterogeniczność - biblioteki zazwyczaj
 mogą być uruchomione tylko przez aplikację skompilowaną dla tej samej platformy
 i w tym samym języku.
 Oprócz tego, aktualizacja takiej biblioteki wymaga ponownej kompilacji
 i instalacji wszystkich aplikacji z niej korzystających.
 Skalowanie takich pojedynczych komponentów również nie jest możliwe, bez
 duplikacji całych korzystających z niej aplikacji.
 Najlepszym zastosowaniem dla tego typu komponentów są współdzielone elementy
 systemu, które nie są kluczowe z punktu widzenia domeny, np.
 zbiory funkcji matematycznych lub klasy pomocnicze dla refleksji
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
\end_layout

\begin_layout Standard
Drugim wariantem jest wyekstrahowanie modułów.
 Moduł jest fragmentem kodu, który powininen realizować proces określony
 w wymaganiach biznesowych systemu.
 Jest to wydzielona część domeny, która realizuje określone przez nią zadania.
 W szczególnym przypadku powinien posiadać własną warstwę dostępu do danych
 lub warstwę prezentacji
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Ważne jest, aby nie unifikować pojęcia związanego kontekstu z modułem
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

.
 Związany kontekst jest raczej zbiorem modułów, istniejących w tym samym
 celu w sensie domeny.
 Dobrą praktyką jest więc tworzenie kilku warstw aplikacji w osobnych modułach
 zawierających się w tej samej przestrzeni nazw, więc wydzielonym kontekście
\begin_inset CommandInset citation
LatexCommand cite
key "Evans2004"

\end_inset

.
\end_layout

\begin_layout Standard
Drugie z tych podejść jest bardziej uwarunkowane różnicami w procesach biznesowy
ch mapowanych na oprogramowanie, więc to taki podział tworzy podwaliny pod
 wydzielenie pełnoprawnych mikrousług.
\end_layout

\begin_layout Subsection
Projektowanie interfejsów REST
\begin_inset CommandInset label
LatexCommand label
name "sub:Projektowanie-interfejsów-REST"

\end_inset


\end_layout

\begin_layout Standard
Mówiąc o komunikacji między usługami nie sposób nie wspomnieć o pojęciu
 zdalnego wywoływania procedur (
\emph on
ang.
 Remote Procedure Call
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/sosp/BirrellN83"

\end_inset

, czyli wykonywaniu operacji, które są realizowane w lokalizacji zdalnej.
 To pojęcie zostało wprowadzone dość dawno, bo w 1983 r.
 ale jest na tyle ogólne, że nie specyfikuje żadnych konkretnych wymagań.
 Z czasem powstało wiele implementacji tego konceptu, takich jak np.
 SOAP (
\emph on
ang.
 Simple Object Access Protocol
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/csi/NavarroS16"

\end_inset

.
 SOAP jest protokołem umożliwiającym przekazywanie obiektów zserializowanych
 do formatu XML przez sieć w celu wykorzystania ich jako parametry funkcji
 (od klienta do serwera) lub jako wynik operacji (od serwera do klienta).
 Jest to protokół który pozwala na przekazywanie tych informacji między
 aplikacjami zaprogramowanymi w różnych technologiach poprzez odpowiednią
 serializację.
 Końcówki obsługujące komunikację SOAP, posiadają również swoją specyfikację
 w języku XML
\begin_inset CommandInset label
LatexCommand label
name "sub:Specyfikacja-SOAP-XML"

\end_inset

, która opisuje jakie operacje można wykonywać przy użyciu danej usługi,
 jakie parametry mogą zostać do niej przekazane i jakiego typu dane wynikowe
 są zwracane.
 Okazuje się jednak, że narzut metadanych wykorzystywanych przez SOAP ma
 negatywny wpływ na jego wydajność
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/services/AihkisaloP12"

\end_inset

.
\end_layout

\begin_layout Standard
REST (
\emph on
ang.
 Representational State Transfer
\emph default
) to styl architektoniczny przeznaczony dla rozproszonych systemów opartych
 o hipermedia.
 Ma on na celu ułatwienie dostępu do zasobów (
\emph on
ang.
 resources
\emph default
) dla systemów w modelu typu klient-serwer, ze znaczną liczbą aktywnych
 aplikacji klienckich.
 Jak wspomniano w rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Architektura-zorientowana-na"

\end_inset

, do komunikacji między mikrousługami powinno stosować się lekkie i szybkie
 rozwiązania, więc podejście REST, które jest sześciokrotnie szybsze niż
 starsze protokoły SOAP
\begin_inset CommandInset citation
LatexCommand cite
key "Trachtenberg2003"

\end_inset

, nadaje się idealnie do tego celu.
 Autor konceptu REST określił pięć wymagań, które umożliwiają bezpieczny
 dostęp do zasobów zachowując spójny stan systemu.
 Dodatkowo opisano wymaganie, które jest opcjonalne.
 Opcjonalne wymaganie wydaje się być oksymoronem, ale w dalszej części tej
 sekcji zostanie ono jasno scharakteryzowane.
\end_layout

\begin_layout Standard
Niezmienniki wyspecyfikowane w opisie REST to
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset

:
\end_layout

\begin_layout Enumerate
Architektura klient-serwer - zastosowanie tej zasady pozwala rozróżnić pojęcia
 interfejsu użytkownika oraz źródła danych, a także umożliwia skalowanie
 i przenośność poszczególnych komponentów niezależnie, w zależności od potrzeb.
\end_layout

\begin_layout Enumerate
Bezstanowość - niniejsza zasada wprowadza wymóg przekazywania wszystkich
 informacji potrzebnych do realizacji zadania przez serwer w ramach jednego
 żądania; nie jest możliwe przechowywanie stanu po stronie serwera.
 Zasada ta znacząco poprawia niezawodność systemu, gdyż w razie jakichkolwiek
 awarii, nie ma potrzeby odtwarzania stanu przetwarzania aby zrealizować
 poprawnie żądanie.
 Oprócz tego, realizacja żądania jest przejrzysta, gdyż nie ma potrzeby
 analizowania jego zawartości, aby określić naturę wywołania.
 Poprawiona jest, w końcu, możliwość rozbudowy systemu, gdyż nie trzeba
 skalować magazynu przechowującego stany aplikacji wszystkich klientów.
\end_layout

\begin_layout Enumerate
Możliwość przechowywania w pamięci o krótkim czasie dostępu (
\emph on
ang.
 cachability
\emph default
) - jest to zasada wykorzystująca idempotentność operacji, aby zaoszczędzić
 zasoby obliczeniowe serwera, a tym zwiększyć wydajność współpracy aplikacji
 klienckiej i serwerowej.
 Pamiętać należy jednak, że wprowadza to do systemu ewentualną zgodność
 danych odczytanych przez użytkownika i rzeczywistych danych na serwerze.
 Projektując więc interfejsy REST, należy poświęcić dużo uwagi na określenie
 polityki częstotliwości wymuszania odświeżania danych, aby dostosować czas
 uzyskania pełnej zgodności danych do wymagań biznesowych.
\end_layout

\begin_layout Enumerate
Ukrycie warstwowej architektury serwera - jest to zasada polegająca na ukrywaniu
 przed aplikacją kliencką faktu, że aplikacja serwerowa jest w rzeczywistości
 zagregowaniem wielu mniejszych usług po stronie serwera.
 Daje to wiele korzyści, takich jak chociażby umożliwienie skalowania systemów,
 poprzez dodanie komponentu równoważącego obciążenie (
\emph on
ang.
 load balancer
\emph default
).
 Jest on wtedy równocześnie serwerem proxy, który w kolejnych warstwach
 może odwoływać się do różnych instancji tej samej aplikacji.
 Możliwe jest również mapowanie zasobów na różne aplikacje serwerowe, bez
 informowania o tym użytkownika lub dokonywanie zmian w aplikacji serwerowej
 bez zmiany implementacji aplikacji klienckich.
\end_layout

\begin_layout Enumerate
Ujednolicony interfejs - ta zasada umożliwia podążanie za konwencją korzystając
 z usług aplikacji serwerowej
\begin_inset CommandInset citation
LatexCommand cite
key "Costa2016"

\end_inset

.
 W tej zasadzie ujawnia się największa zaleta systemów opartych o REST,
 gdyż zapewnia uniwersalność aplikacji serwerowej i proste zasady, które
 spełniać powinna aplikacja kliencka, aby komunikować się z serwerem.
 Właśnie to zadecydowało o tak dużej popularności interfejsów typu REST
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/icws/FokaefsS15"

\end_inset

.
 Wadą jednolitego interfejsu jest to, że każda aplikacja uzyskuje pełną
 informację o zasobie, bez względu na to jaki jaki podzbiór jest przez nią
 wymagany.
 W ramach tego niezmiennika wyróżnia się cztery punkty, opisujące dokładniej
 zasadę ujednoliconego interfejsu
\begin_inset CommandInset citation
LatexCommand cite
key "Athanasopoulos2015"

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
Identyfikacja zasobów - używanie stałych identyfikatorów zasobu (np.
 URI w interfejsach REST opartych o sieć WWW).
\end_layout

\begin_layout Enumerate
Manipulacja zasobami przez ich reprezentację - zasada mówiąca o tym, że
 aplikacja kliencka może manipulować zasobami tylko w zakresie informacji
 uzyskanych przez odczyt.
\end_layout

\begin_layout Enumerate
Samoopisujące się wiadomości - każda wiadomość powinna zawierać wystarczającą
 informację opisującą jak przetworzyć żądanie.
 Przykładem może być identyfikator MIME w nagłówku `Content-type` w przypadku
 protokołu HTTP
\end_layout

\begin_layout Enumerate
Hipermedium jako silnik stanu aplikacji (
\emph on
ang.
 Hypermedia as the engine of application state
\emph default
) (HATEOAS) - zasada umożliwiająca zrozumienie zasobu i jego zależności
 dzięki rozróżnianiu go przez stałe identyfikatory oraz reprezentowanie
 zależności przez przekazywanie tych identyfikatorów
\begin_inset CommandInset citation
LatexCommand cite
key "Costa2016"

\end_inset

.
 Niezaprzeczalną wadą tego rozwiązania, jest potrzeba wykonania większej
 ilości zapytań, aby uzyskać pełen obraz bardziej złożonego zasobu.
\end_layout

\end_deeper
\begin_layout Enumerate
Udostępnianie kodu na żądanie* - jest to zasada opcjonalna, która polega
 na umożliwieniu aplikacji klienckiej uzyskiwanie kodu, który można wykonać
 po stronie klienta.
 Przykładem przychodzącym na myśl w pierwszej kolejności jest pobieranie
 kodu JavaScript przez przeglądarki internetowe.
 Pozorna sprzeczność pojęcia opcjonalnego wymagania, może zostać wyjaśniona
 przez podkreślenie, że system implementujący REST powinien dać sposobność
 wykonania kodu, ale wykorzystywanie tej możliwości należy ograniczyć do
 szczególnych przypadków w kontrolowanych warunkach.
\end_layout

\begin_layout Standard
Specyfika interfejsu typu REST uwydatnia, kwestie które powinny zostać rozważone
 podczas weryfikacji oprogramowania opartego o ten styl architektoniczny.
 Przetestować należy wówczas nie tylko funkcjonalne właściwości serwisu,
 ale również zgodność z założeniami stylu w którym jest on realizowany
\begin_inset CommandInset citation
LatexCommand cite
key "Costa2016"

\end_inset

.
\end_layout

\begin_layout Subsection
Połączenia między usługami
\end_layout

\begin_layout Standard
Wizja ogromnego systemu złożonego z wielu komponentów, realizującego skomplikowa
ne zadania nasuwa na myśl skomplikowane połączenia między komórkami systemu.
 Istnieje wiele systemów, w których istnieją dodatkowe komponenty odpowiadające
 tylko i wyłącznie za realizację komunikacji.
 Komponenty takie zaimplementowane mają często skomplikowane reguły przekazywani
a wiadomości w zależności od logiki biznesowej.
 Przykładem są produkty typu ESB (
\emph on
ang.
 Enterprise Service Bus
\emph default
), które zawierają skomplikowane funkcje trasowania wiadomości, kapsułkowania
 lub transformacji danych.
 Komponenty takie, jako że są wspólne dla całego systemu, są trudno skalowalne,
 więc generują duże ryzyko wystąpienia wąskiego gardła.
 Mechanizm komunikacji powinien być prostą częścią systemu spełniając zasadę
 
\begin_inset Quotes pld
\end_inset

inteligentne punkty końcowe i naiwne kanały komunikacji
\begin_inset Quotes prd
\end_inset

 (
\emph on
ang.
 smart endpoints and dumb pipes
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2014"

\end_inset

.
 Społeczność skupiona na rozwijaniu konceptu mikrousług proponuje proste
 wywołania HTTP w celu wymiany danych między usługami.
 Niższe warstwy sieciowego modelu OSI zrealizują więc komunikację, a zadaniem
 
\begin_inset Quotes pld
\end_inset

inteligentnych punktów końcowych
\begin_inset Quotes prd
\end_inset

 jest analiza żądań i generowanie odpowiedzi.
 
\end_layout

\begin_layout Standard
Wykorzystywanie prostych protokołów komunikacyjnych zrzuca niejako z programistó
w ciężar projektowania i implementowania mechanizmów komunikacji oraz dostarcza
 całą gamę gotowych i sprawdzonych rozwiązań, które nie obciążają niepotrzebnie
 systemu.
 
\end_layout

\begin_layout Standard
Proste protokoły sieciowe, mimo niezaprzeczalnych zalet w sensie wydajnościowym,
 mogą być niewystarczające dla niektórych zastosowań.
 Protokół HTTP nie jest niezawodny, więc dla krytycznych punktów systemu
 wprowadzić można kolejki komunikatów, które nie realizują logiki biznesowej,
 a tylko zapewniają niezawodność komunikacji asynchronicznej niewielkim
 kosztem wydajności
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/fgcs/ZounmevoA14"

\end_inset

.
\end_layout

\begin_layout Standard
Praktyka pokazuje jednak, że istnieją przypadki, kiedy konieczne jest wyposażeni
e warstwy komunikacyjnej w komponent wspomagający, tzw.
 bramę interfejsów (
\emph on
ang.
 API gateway
\emph default
).
 Brama taka ma za zadanie agregować żądania tak, aby możliwie mała ich liczba
 była wymieniana między aplikacją kliencką, a usługami
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Podejście to stosowane jest często w przypadku aplikacji mobilnych, gdzie
 użytkownicy końcowi dysponują limitowaną ilością przesyłanych danych w
 ramach ich pakietu internetowego.
 Ta koncepcja może być zastosowana w dwóch wariantach.
 Pierwszym, jest jedna, monolityczna brama interfejsów, która używana jest
 kiedy mamy niewiele (najczęściej jedną) aplikację z niej korzystającą.
 Wariant drugi to odseparowane bramy dla wielu aplikacji końcowych w tzw.
 zaplecza (
\emph on
ang.
 backends for frontends
\emph default
).
 Oba podejścia zaprezentowane są na rysunkach 
\begin_inset CommandInset ref
LatexCommand ref
reference "Ryc21"

\end_inset

 oraz 
\begin_inset CommandInset ref
LatexCommand ref
reference "Ryc22"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Api-Gateway-monolithic.PNG
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Ryc21"

\end_inset

 Monolityczna brama interfejsów
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Api-Gateway-frontend-for-backend.PNG
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Ryc22"

\end_inset

 Wiele bram dla aplikacji końcowych
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Dokumentacja oprogramowania
\end_layout

\begin_layout Standard
Opracowanie dokumentacji jest nieodłączną częścią procesu wytwarzania oprogramow
ania
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/acm/ViscontiC93,DBLP:conf/ecbs/BayerM06"

\end_inset

.
 Prowadzenie dokumentacji ma oczywiście wiele zalet, jednak jest również
 źródłem dyskusji na temat opłacalności pod względem biznesowym
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/jss/ZhiGSGSR15"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Definicja terminu oraz rola dokumentacji
\begin_inset CommandInset label
LatexCommand label
name "sub:Definicja-terminu-oraz"

\end_inset


\end_layout

\begin_layout Standard
Dokumentacja to artefakt, którego celem jest przekazywanie innym informacji
 o systemie, którego dotyczy
\begin_inset CommandInset citation
LatexCommand cite
key "Forward2002"

\end_inset

.
 Dokumentacja może również odnosić się do dokumentów stworzonych przez programis
tów dla użytkowników nietechnicznych, zwanych wtedy instrukcją
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/jss/ZhiGSGSR15"

\end_inset

.
 Wyróżnić można też specyfikację, która jest technicznym opisem oprogramowania,
 przeznaczonym dla użytkowników, którymi są inni programiści.
 Korzystają oni więc tylko z interfejsów udostępnionych przez usługi, ale
 rzadko uczestniczą w ich rozwoju
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
\end_layout

\begin_layout Standard
W przypadku zbioru usług, często wykorzystywane są centralne, dynamiczne
 rejesty usług, które udostępniają informację o tym jakie usługi są dostępne
 i w jaki sposób nawiązać z nimi łączność.
 Zazwyczaj nie udostępniają jednak informacji o tym jakie funkcje są przez
 te usługi oferowane.
 Funkcję tę może pełnić techniczna dokumentacja, którą można pobrać wykonując
 ustalone żądanie
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Taki typ żądania jest oferowany przez protokół 
\emph on
HTTP
\emph default
 - chodzi o metodę 
\emph on
OPTIONS
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "http-rfc"

\end_inset

.
 Po wywołaniu takiej metody serwer może zwrócić plik dokumentacji.
\end_layout

\begin_layout Subsection
Formalna specyfikacja usług sieciowych
\end_layout

\begin_layout Standard
Należy zauważyć, że dokumentacja techniczna nie musi być dokumentem pisanym
 w języku naturalnym, a jedynie precyzyjną informacją dla inżynierów pracujących
 nad systemem lub chcących uzyskać do niego dostęp
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/jss/ZhiGSGSR15"

\end_inset

.
 W sekcji 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Definicja-terminu-oraz"

\end_inset

 opisano możliwość udostępniania dokumentacji technicznej poprzez wywołanie
 odpowiedniego żądania.
 Pobrana dokumentacja może potem zostać wczytana automatycznie przez parser,
 który jest w stanie zinterpretować jej treść.
 Trudno byloby analizować dokumentację pisaną w języku naturalnym, więc
 powstało kilka technologii, które opisują interfersy w zrozumiały dla maszyny
 sposób i pozwalają na wykorzystanie tej wiedzy przez program komputerowy.
 Przykładadami takich rozwiązań są 
\emph on
Swagger
\emph default
, 
\emph on
HAL
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

 lub 
\emph on
RAML
\emph default
.
\end_layout

\begin_layout Standard
Wpomniany wcześniej, w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Specyfikacja-SOAP-XML"

\end_inset

, SOAP posiada specyfikację interfejsu sieciowego wbudowaną w sam protokół.
 Ta formalna dokumentacja opisana jest w jezyku XML o schamacie zdefiniowanym
 jako WSDL (
\emph on
ang.
 Web Services Description Language
\emph default
)
\begin_inset CommandInset citation
LatexCommand cite
key "citeulike:99946"

\end_inset

.
\end_layout

\begin_layout Subsection
Koszty rozwoju i utrzymania
\end_layout

\begin_layout Standard
Koszty wytworzenia dokumentacji szacunkowo wynoszą ok.
 11%
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/iwsm/Sanchez-RosadoRMCMG09"

\end_inset

.
 Jest to oczywiście znaczący koszt, który z biznesowego punktu widzenia
 powinien być minimalizowany, zachowując jakość, a ściśle mówiąc wartość
 informacji, która zawarta jest w dokumentacji.
 Wraz z wzrostem popularności zwinnych metodologii 
\begin_inset CommandInset citation
LatexCommand cite
key "PMI2012"

\end_inset

 zespoły deweloperskie coraz częściej stawiają działające oprogramowanie
 i samoopisujący się kod ponad dokumentają
\begin_inset CommandInset citation
LatexCommand cite
key "beck2001agile"

\end_inset

.
 Siłą rzeczy, pisanie dokumentacji jest pomijane lub zaniedbywane, a często
 istniejąca dokumentacja nie jest uaktualniana, więc staje się coraz bardziej
 rozbieżna z oprogramowaniem.
\end_layout

\begin_layout Subsection
RAML
\end_layout

\begin_layout Standard
RAML (
\emph on
RESTful API Modeling Language
\emph default
) to język służący do dokumentowania interfejsów usług sieciowych zbudowanych
 w zgodzie z opisanym w sekcji 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Projektowanie-interfejsów-REST"

\end_inset

, stylem architekonicznym 
\emph on
REST
\emph default
 w oparciu o protokół 
\emph on
HTTP
\emph default
.
 Jest on oparty na składni 
\emph on
YAML 
\emph default
i pozwala na intuicyjne odwzorowanie hierarchicznego modelu zasobów w 
\emph on
REST
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "raml2016"

\end_inset

.
 
\end_layout

\begin_layout Standard
Specyfikacja 
\emph on
RAML 
\emph default
podzielona jest na dwie główne części: pierwsza to zbiór metadanych na temat
 całego serwisu, a druga to zbiór zasobów oferowanych przez daną usługę
 wraz z ich szczegółową specyfikacją.
 Na część pierwszą składają się np.
 tytuł, wersja, bazowy adres internetowy, schemat struktury danych, informacje
 na temat uzyskiwania autoryzacji lub typy danych.
 Szczegółowa specyfikacja zawarta w części drugiej dokumentacji podzielona
 jest głównie na hierarchicznie uporządkowane segmenty, z których każdy
 opisuje jakiś zasób.
 Opis zasobu może składać się z następujących właściwości:
\end_layout

\begin_layout Itemize
displayName - nazwa zasobu,
\end_layout

\begin_layout Itemize
description - szczegółowy opis zasobu,
\end_layout

\begin_layout Itemize
metoda dostępu do danych (get, patch, put, post, delete, options, head),
\end_layout

\begin_layout Itemize
type - typ zasobu; realizuje niejako dziedziczenie kopiując wszystkie własności
 z wybranego typu,
\end_layout

\begin_layout Itemize
is - cecha zasobu; realizuje dziedziczenie w węższym zakresie niż typ, a
 mianowicie odnosi się do specyfikacji metod,
\end_layout

\begin_layout Itemize
securedBy - definiuje schemat autoryzacji dostępu do zasobu,
\end_layout

\begin_layout Itemize
uriParameters - lista możliwych parametrów przekazywanych w adresie URI,
\end_layout

\begin_layout Itemize
/<relativeUri> - podrzędny zasób, który opisany może zostać w ten sam sposób,
\end_layout

\begin_layout Itemize
<annotationName> - dodatkowe adnotacje, pozwalające na zawarcie dodatkowych
 informacji na temat zasobu.
\end_layout

\begin_layout Standard
Każda metoda na liście, również opisana jest wieloma własnościami:
\end_layout

\begin_layout Itemize
displayName - alternatywna nazwa metody, odnosząca się do rzeczywistej operacji
 przez nią dokonywanej w kontekście wiedzy domenowej,
\end_layout

\begin_layout Itemize
description - dłuższy opis metody,
\end_layout

\begin_layout Itemize
(<annotationName>) -dodatkowe adnotacje, pozwalające na zawarcie dodatkowych
 informacji na temat zasobu,
\end_layout

\begin_layout Itemize
queryParameters - szczegółowe informacje o parametrach zapytania używanych
 w ramach metody; wzajemnie wykluczające się z własnością 
\emph on
queryString,
\end_layout

\begin_layout Itemize
headers - szczegółowe informacje na temat nagłówków zapytania 
\emph on
HTTP
\emph default
,
\end_layout

\begin_layout Itemize
queryString - zagregowany ciąg znaków zawierający parametry; wzajemnie wykluczaj
ące się z własnością queryParameters,
\end_layout

\begin_layout Itemize
responses - informacja o możliwych odpowiedziach z serwera identyfikowane
 kodem odpowiedzi,
\end_layout

\begin_layout Itemize
body - informacja o strukturze, zawartości, możliwych wartościach oraz formacie
 zawartości sekcji 
\emph on
body 
\emph default
zapytania,
\end_layout

\begin_layout Itemize
protocols - lista protokołów używanych do wywałania metody; ta własność
 nadpisuje jakiekolwiek wartości protokołów definiowane wyżej w hierarchi,
\end_layout

\begin_layout Itemize
is - lista cech, które opisują szczegóły metody,
\end_layout

\begin_layout Itemize
securedBy - definiuje schemat autoryzacji dostępu do zasobu.
\end_layout

\begin_layout Standard
Składnia RAML jest oczywiście dużo szersza i umożliwia jeszcze bardziej
 szczegółowe definiowanie interfejsów REST.
 Z punktu widzenia tej pracy, są one jednak nieistotne a opisane wyżej elementy
 szczegółowo omówione będą w rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Proponowane-rozwiązanie"

\end_inset

.
\end_layout

\begin_layout Section
Testowanie
\end_layout

\begin_layout Standard
Implementacja mikrousług a tym bardziej przepisywanie istniejącego monolityczneg
o systemu na architekturę mikroserwisową jest bardzo trudne i czasochłonne
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/edoc/SaezAWM14"

\end_inset

, więc aby zredukować koszty zespołu deweloperskiego należy oszczędzać czas
 programistów, między innymi rezygnując z pisania części testów.
 Oczywiście, nie można pozwolić sobie na obniżenie jakości oprogramowania,
 więc testy pominięte przez programistów można generować automatycznie.
 Idealnym źródłem danych wydaje się być dokumentacja techniczna interfejsów
 usług.
\end_layout

\begin_layout Standard
Mikrousługi jako koncepcj, wymagają również zapewnienia w pełni zautomatyzowaneg
o dostarczania oprogramowania.
 Oznacza to, że powinno się zrezygnować z testów ręcznych na rzecz rzetelnie
 sporządzonych testów automatycznych
\begin_inset CommandInset citation
LatexCommand cite
key "Newman2015"

\end_inset

.
 Kolejnym krokiem może być również automatyzacja generowania takich testów,
 a następnie automatyczne ich uruchomienie i weryfikacja.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Testowanie-funkcjonalne"

\end_inset

Testowanie funkcjonalne
\end_layout

\begin_layout Standard
Wśród wielu rodzajów i technik testowania oprogramowania, na uwagę w kontekście
 tej pracy zasługuje testowanie funkcjonalne.
 Polega ono na takim wyborze przypadków testowych, aby pokryć wymagania
 funkcjonalne, które ma spełniać oprogramowanie
\begin_inset CommandInset citation
LatexCommand cite
key "Arsie2014222"

\end_inset

.
 Testowanie funkcjonalne znane jest również jako tesowanie czarnoskrzynkowe
 lub testowanie oparte o specyfikację
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/daglib/0017273"

\end_inset

.
 
\end_layout

\begin_layout Standard
Wyodrębnić można wiele różnych podziałów technik testowania, takich jak
 podział ze względu na zakres, ze względu na przedmiot testów albo ze względu
 na sposób ich wykonywania
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/daglib/0017273"

\end_inset

.
 Testy można również podzielić na systematyczne lub losowe
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/daglib/0017273"

\end_inset

.
 Przypadki testowe w kontekście testownia funkcjonalnego powinny być testami
 systematycznymi, czyli wartości argumentów oraz spodziewany wynik powinien
 zostać jasno określony podczas definiowania testu
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/daglib/0017273"

\end_inset

.
 Źródłem takich informacji są 
\emph on
wyrocznie, 
\emph default
czyli byty (dokumenty, artefakty, wiedza ekspercka)
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/tse/StocksC96"

\end_inset

.
 Skoro więc testy te są oparte na specyfikacji, ona powinna służyć jako
 wyrocznia.
 Powinna ona w takim razie definiować nie tylko sposób operowania na danych,
 ale również przykładowe dane wejściowe oraz oczekiwane wyniki.
\end_layout

\begin_layout Standard
Rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proces-tworzenia-testów"

\end_inset

 pokazuje proces powstawania przypadku testowego zaproponnowanego przez
 Prezze i Younga.
 Pierwszym krokiem jest zidentyfikowanie niezależnej funkcjonalności lub
 cechy systemu informatycznego.
 Będzie ona przedmiotem testu.
 Następnie należy wybrać wartości wejściowe oraz przeanalizować zasady zachowani
a funkcjonalności, w celu określenia oczekiwanego wyniku.
 Analiza w celu określenia rezultatu jest opcjonalna.
 Wynik można określić również przy pomocy wyroczni, więc zgodnie z zasadami
 testowania czarnoskrzynkowego, można stworzyć specyfikację przypadku testowego
 bez wiedzy eksperckiej.
 Ostatnim krokiem jest wygenerownie przypadku testowego na podstawie jego
 specyfikacji.
 Wynikiem może być na przykład dokument definiujący testy lub kod źródłowy
 tesów.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Systematic-functional-testing.PNG
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Proces-tworzenia-testów"

\end_inset

Proces tworzenia testów funkcjonalnych
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/daglib/0017273"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Przedmiot testowania w przypadku interfejsów REST
\end_layout

\begin_layout Standard
Rozwijanie aplikacji z interfejsami programistycznmi polega tak naprawdę
 na dodaniu dodatkowej warstwy oprogramowania.
 Jest to więc dodatkowa warstwa, którą należy objąć testami
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/erlang/SeijasLT13"

\end_inset

.
\end_layout

\begin_layout Standard
Testy interfejsów REST posiadają specyfikę wymagającą podejścia do testów
 w taki sposób, aby pokryć przypadki wynikające z założeń stylu architektoniczne
go REST
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/erlang/SeijasLT13"

\end_inset

.
 Takimi aspektami są:
\end_layout

\begin_layout Itemize
Zgodność interfejsu z zasadami REST,
\end_layout

\begin_layout Itemize
Zgodność formatu zserializowanych obiektów z zadanym,
\end_layout

\begin_layout Itemize
Testy scenariuszy (najpierw dodawanie, potem usuwanie, weryfikacja czy usunięcie
 się powiodło),
\end_layout

\begin_layout Itemize
Testy bezpieczeństwa,
\end_layout

\begin_layout Itemize
Testy wydajności komunikacji.
\end_layout

\begin_layout Standard
O ile pierwsze trzy punkty realizują założenia testów funkcjonalnych, to
 kolejnych dwóch nie można za takie uznać.
 W ramach tej pracy, skupimy się więc na pierwszych trzech aspektach testowania.
 
\end_layout

\begin_layout Subsection
Ciągła integracja
\end_layout

\begin_layout Standard
W kontekście testowania funkcjonalnego, proces ciągłej integracji jest ważnym
 elementem weryfikacji oprogramowania poprzez testy regresyjne.
 Każda zmiana w kodzie źródłowym programu, skutkuje rozpoczęciem iteracji
 procesu budowania oprogramowania, a następnie wykonania testów zdefiniowanych
 wcześniej
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/ro-man/AblettSMDS07"

\end_inset

.
 Jest to niejako mechanizm samoobrony procesu rozwoju oprogramownia
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/icsea/DownsHP10"

\end_inset

.
 Skoro oprogramowanie jest cały czas testowane możemy być pewni, że kod
 jest spójny ze specyfikacją.
 Częstym bowiem problemem jest fakt, że kod ewoluuje, a jego specyfikacja
 zostaje zaniedbana.
 Powoduje to powstawanie rozbieżności i niespójności pomiędzy dokumentacją
 i specyfikacją, a rzeczywiście używanym oprogramowaniem
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/daglib/0028697"

\end_inset

.
\end_layout

\end_body
\end_document
